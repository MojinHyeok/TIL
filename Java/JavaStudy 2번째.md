**목표** 자바의 프리미티브 타입, 변수 그리고 사용하는 방법을 익힙니다.

**학습할 내용.**

- 프리미티브 타입 종류와 값의 범위 그리고 기본 값
- 프리미티브 타입과 레퍼런스 타입
- 리터럴
- 변수 선언 및 초기화하는 방법
- 변수의 스코프와 라이프타임
- 타입 변환, 캐스팅 그리고 타입 프로모션
- 1차 및 2차 배열 선언하기
- 타입 추론, var



## **프리미티브 타입 종류와 값의 범위 그리고 기본 값**

프리미티브 타입(Primitive Type) 이란?

기본자료형이라고 불리는 프리미티브 타입은 값을 할당할 때 변수의 주소값에 값이 그 자체로 저장되는 데이터 타입입니다.

프리미티브 타입의 종류

Java에서는 크게 타입의 종류로서는 총 8가지가 존재합니다.

| **타입** | **bit** | **byte** | **값의 범위**                                          | **기본 값** | **분류** |
| -------- | ------- | -------- | ------------------------------------------------------ | ----------- | -------- |
| byte     | 8       | 1        | -128 ~ 127                                             | 0           | 정수형   |
| short    | 16      | 2        | -32,768 ~ 32,767                                       | 0           | 정수형   |
| int      | 32      | 4        | -2,147,483,648 ~ 2,147,483,647                         | 0           | 정수형   |
| long     | 64      | 8        | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 0L          | 정수형   |
| float    | 32      | 4        | 1.4E-45 ~ 3.4028235E38                                 | 0.0f        | 실수형   |
| double   | 64      | 8        | 4.9E-324 ~ 1.7976931348623157E308                      | 0.0d        | 실수형   |
| char     | 16      | 2        | ‘\u0000’ ~ ‘\uffff’ (0 ~ 65,535)                       | ‘\u0000’    | 문자형   |
| boolean  | 8       | 1        | true/false                                             | false       | 논리형   |

값의 범위의 경우 해당 타입의 차지하는 비트 수에 의해 결정됩니다.
boolean타입의 경우 true와 false두 값만 표현하면 되기 때문에 1바이트(8비트) 면 값을 표현할 수 있습니다.

char 타입의 경우 자바에서 유니코드(2 byte 문자 체계)를 사용하기에 2byte를 사용합니다.

int와 long타입의 경우 32비트와 64비트를 차지하므로 각각 2^31-1와 2^63-1의 범위를 가지게 됩니다.

실수형은 부동소수점방식으로 저장을 합니다. 



## **프리미티브 타입과 레퍼런스 타입**.

Java에서는 데이터를 저장하는 방법으로 프리미티브 타입과 레퍼런스 타입이 있습니다.

프리미티브 타입은 위에서 설명드린 바와 같이 byte, short, int, long, float, double, char, boolean 등이 있습니다. 이들은 각각 다른 크기의 메모리를 차지하며 값 자체가 저장됩니다.

반면 레퍼런스 타입은 객체의 참조값을 저장하는 타입입니다. 클래스, 인터페이스, 배열 등이 이에 해당합니다. 레퍼런스 타입 변수는 힙 영역에 생성된 객체의 참조값을 저장합니다.

프리미티브 타입의 경우 스택 메모리에 실제 값들이 저장되어집니다.

레퍼런트 타입의 경우 실제 인스턴스는 힙영역에 생성되고, 그 영역의 주소를 스택영역에 저장되어 있습니다.



## **리터럴**

리터럴은 자바프로그램에서 사용되는 상수 값입니다.(데이터 그 자체를 의미.)

여러 가지 타입의 리터럴이 존재하며 예시는 다음과 같습니다.

\1. 정수형 리터럴

정수 값을 나타내는 데 사용됩니다.

자바에서는 10진수, 8진수, 16진수 등의 정수형 리터럴을 사용할 수 있습니다.

```
int x = 100;       // 10진수 리터럴
int y = 0xFF;      // 16진수 리터럴
int number = 1_000_000_000;//큰 수에 관하여 가독성을 쉽게 하기 위해 언더바로 구분이 가능합니다.
```

\2. 실수형 리터럴

실수 값을 나타내는 데 사용됩니다. 자바에서는 부동소수점 리터럴과 배정도 부동소수점 리터럴을 사용할 수 있습니다.

```
double d = 123.45;         // 부동소수점 리터럴
float f = 1.23e-3f;        // 배정도 부동소수점 리터럴
```

\3. 문자 리터럴

문자 리터럴은 문자에 대한 나타내는데 사용되어집니다. 크게 char와 String을 활용하여 나타냅니다.

```
char c = 'a';
String str = "abc";
```





## **변수 선언 및 초기화하는 방법**

**변수선언**

변수선언을 할 때에 데이터의 유형과 변수 이름을 지정해야 합니다.

```
int age;              // 정수형 변수 age 선언
double salary;        // 실수형 변수 salary 선언
String name;          // 문자열 변수 name 선언
```

위와 같은 예시가 있다면 먼저 변수타입을 먼저 선언한 이후, 변수이름을 지정해 주어서 사용합니다.

이렇게 변수를 선언하면, 메모리의 빈 공간에 변수타입에 알맞은 크기의 저장공간이 확보가 되고, 변수이름을 붙여서 변수이름을 통하여 메모리 공간을 사용할 수 있게 됩니다.

**변수 초기화**

변수를 사용하기 전 처음으로 값을 저장하는 개념.

위의 변수선언 상태에서는 메모리 공간만 확보했지, 메모리에 어떠한 값을 저장하지는 않은 상태입니다. 

그리고 변수는 여러 프로그램에 의해 공유되기 때문에, 초기화 과정을 통해 값을 할당해주어야 합니다.

변수는 여러 프로그램에서 공유될 수 있으므로, 초기화 과정을 통해 원하는 값을 할당해주어야 합니다. 이를 통해 변수가 예상치 못한 값으로 초기화되어 문제가 발생하는 것을 방지할 수 있습니다.

초기화의 예시는 다음과 같습니다.

```
int age = 27;                 // 정수형 변수 age 선언 및 초기화
double salary = 50000.0;      // 실수형 변수 salary 선언 및 초기화
String name = "John Smith";   // 문자열 변수 name 선언 및 초기화
```





## **변수의 스코프와 라이프타임**

변수의 스코프는 변수가 유효한 범위를 나타냅니다. 범위의 경우 키워드와 선언된 블록위치에 따라서 달라지게 됩니다.

변수의 라이프타임은 변수가 메모리에서 유효한 시간을 나타냅니다. 자바에서는 변수의 라이프타임을 변수의 선언 위치에 따라 결정합니다.

**선언위치에 따른 변수**

```
class  ScopeAndLifetime {
	int instanceValue; //인스턴스 변수
	static int classValue;//클래스 변수

	void method(){
		int localValue = 0; //지역 변수
	}
}
```

**1. 인스턴스 변수**

인스턴스 변수는 클래스 내에서 선언된 변수입니다. 인스턴스 변수는 객체가 생성될 때 생성되고, 객체가 사용되는 동안에는 계속해서 메모리에 유지됩니다. 객체가 가비지 컬렉터에 의해 수집될 때, 인스턴스 변수도 함께 제거됩니다.

**2. 클래스 변수**

클래스 변수는 static 키워드로 선언된 변수입니다. 클래스 변수는 클래스가 로드될 때 생성되고, 프로그램이 종료될 때까지 메모리에 유지됩니다. 클래스 변수는 인스턴스를 생성하지 않고 클래스가 메모리에 올라갔을 때 선언되기 때문에 인스턴스에서는 언제든 바로 접근해서 사용할 수 있습니다. 그렇기에 어디서나 접근할 수 있는 전역변수의 성격을 가지게 됩니다.

**3. 지역변수**

지역변수는 메서드나 블록 내에서 선언된 변수입니다. 지역변수는 선언된 블록에서 실행이 끝날 때까지 메모리에 유지됩니다. 메서드가 호출되면 해당 메소드 내에서 선언된 모든 지역변수가 생성되고, 메소드가 종료되면 메모리에서 제거됩니다.

```
public static void main(String[] args) {
	for (int i = 0; i < 10; i++) {
        System.out.println(i);
    }
    System.out.println(i);//에러발생
}
```

클래스변수와 인스턴스 변수의 차이

클래스 변수: 클래스가 로드될 때 메모리에 할당됩니다. 해당 클래스의 모든 인스턴스에서 공유되는 변수이며, 객체 생성 없이도 사용할 수 있습니다.

인스턴스 변수: 객체가 생성될 때 메모리에 할당됩니다. 각 객체마다 고유한 값을 가지며, 객체가 생성되기 전에는 사용할 수 없습니다.

```
public class MyClass {
    static int classVariable; // 클래스 변수
    int instanceVariable; // 인스턴스 변수

    public static void main(String[] args) {
        System.out.println(MyClass.classVariable); // 클래스 변수 사용 가능 (출력: 0)
//        System.out.println(MyClass.instanceVariable);//한다면에러 발생

        MyClass obj1 = new MyClass();
        obj1.instanceVariable = 10;
        System.out.println(obj1.instanceVariable); // 인스턴스 변수 사용 가능 (출력: 10)
        System.out.println(obj1.classVariable); // 클래스 변수 사용 가능 (출력: 0)

        MyClass obj2 = new MyClass();
        obj2.instanceVariable = 20;
        System.out.println(obj2.instanceVariable); // 인스턴스 변수 사용 가능 (출력: 20)
        System.out.println(obj2.classVariable); // 클래스 변수 사용 가능 (출력: 0)

        MyClass.classVariable = 30; // 클래스 변수 값 변경 가능
        System.out.println(obj1.classVariable); // 모든 인스턴스에서 공유되는 클래스 변수 값 변경됨 (출력: 30)
        System.out.println(obj2.classVariable); // 모든 인스턴스에서 공유되는 클래스 변수 값 변경됨 (출력: 30)
    }
}
```

위 코드에서 MyClass 클래스는 클래스 변수 classVariable과 인스턴스 변수 instanceVariable을 가지고 있습니다.

main()메서드에서 먼저 MyClass.classVariable을 출력하여 클래스 변수가 사용 가능하다는 것을 확인합니다.(생성을 하지지 않아도 클래스가 로드될 때 메모리에 할당되기 때문에 접근이 가능)

그 후, obj1과 obj2 객체를 생성하고, 각각의 instanceVariable 값을 설정합니다.

obj1과 obj2 객체의 classVariable 값은 클래스 변수이기 때문에, MyClass.classVariable과 동일하게 0으로 초기화되어 있습니다.

마지막으로, MyClass.classVariable 값을 변경하고 obj1.classVariable과 obj2.classVariable 값을 출력하여 클래스 변수가 모든 인스턴스에서 공유된다는 것을 확인합니다.

## **타입 변환, 캐스팅 그리고 타입 프로모션**

**타입변환** : 변수 또는 상수의 타입을 다른 타입으로 변환하는 작업을 진행하는 것.

연산작업을 수행할 때에 서로의 타입을 일치시켜줘야 하는데 , 이렇게 변수나 리터럴의 타입을 다른 타입으로 변환하는 작업을 형변환이라고 합니다.

```
int num = 100;
byte b = (byte) num;
```

위와 같이 형변환을 진행할 수 있는데, 큰 타입에서 작은 타입으로 변환할 때에는 데이터 손실이 발생할 수 있으므로 주의해야 합니다.

**캐스팅 : 데이터 타입을 명시적으로 변환하는 방법.**

변환될 타입 변수 = (변환될 타입) 변환할 값;

```
double d = 3.14;
int i = (int) d;
```

위와 같이 캐스팅을 진행할 수 있습니다. 하지만 이럴 경우. double형 변수의 d의 소수점 이하값은 모두 손실되고 int형 변수인 i에는 3이 할당되게 됩니다. 이러한 작업 때문에 데이터손실을 주의해야 합니다.

**타입프로모션 :** 작은 자료형의 값이 큰 자료형으로 자동으로 변환되는 것을 말합니다. 이는 자동으로 이루어지며, 명시적으로 캐스팅을 할 필요가 없습니다.

타입 프로모션은 대부분의 연산자와 메서드 호출에서 자동으로 이루어집니다.

```
int num1 = 10;
double num2 = 3.14;
double result = num1 + num2;
```

위 코드에서 num1은 int 타입이고 num2는 double 타입입니다. num1과 num2를 더할 때 num1이 double 타입으로 자동으로 변환되어 덧셈 연산이 이루어집니다. 이때 num1의 값이 10.0으로 변환되어 덧셈이 이루어집니다. 결과적으로 result는 double 타입의 13.14 값이 됩니다.



## **1차 및 2차 배열 선언하기**

**배열(Array)**

배열은 동일한 데이터 타입의 요소(Element)들이 모여있는 자료구조입니다. Java에서 배열은 고정된 크기를 가지며, 인덱스(Index)를 사용하여 요소에 접근할 수 있습니다. Java에서는 1차 배열과 2차 배열을 선언할 수 있습니다.



**1차 배열 선언하기**

1차 배열은 요소가 한 줄로 연속적으로 저장되는 배열입니다. 1차 배열을 선언하는 방법은 다음과 같습니다.

```
// 배열 타입[] 배열 이름 = new 배열 타입[배열 크기];
int[] arr1 = new int[5]; // int 타입의 5개 요소를 가진 1차원 배열 선언
double[] arr2 = new double[10]; // double 타입의 10개 요소를 가진 1차원 배열 선언
String[] arr3 = new String[7]; // String 타입의 7개 요소를 가진 1차원 배열 선언
```

위 코드에서 **arr1**, **arr2**, **arr3**은 각각 int, double, String 타입의 배열이며, 크기가 각각 5, 10, 7입니다. 이때 배열의 인덱스는 0부터 시작합니다.

1차 배열을 초기화하는 방법은 다음과 같습니다.

```
int[] arr1 = {1, 2, 3, 4, 5}; // 크기가 5이고 값이 1부터 5까지인 1차원 배열 선언 및 초기화
double[] arr2 = new double[]{3.14, 2.5, 1.0}; // 크기가 3이고 값이 3.14, 2.5, 1.0인 1차원 배열 선언 및 초기화
String[] arr3 = new String[]{"apple", "banana", "cherry"}; // 크기가 3이고 값이 apple, banana, cherry인 1차원 배열 선언 및 초기화
```

위 코드에서 **arr1**, **arr2**, **arr3**는 각각 초기화된 int, double, String 타입의 배열입니다.

**2차 배열 선언하기**

2차 배열은 요소가 여러 줄로 나누어져 저장되는 배열입니다. 2차 배열을 선언하는 방법은 다음과 같습니다.

```
javaCopy code
// 배열 타입[][] 배열 이름 = new 배열 타입[행의 개수][열의 개수];
int[][] arr1 = new int[3][4]; // int 타입의 3x4 행렬을 가진 2차원 배열 선언
double[][] arr2 = new double[2][3]; // double 타입의 2x3 행렬을 가진 2차원 배열 선언.
```



## **타입 추론, var**

Java 10에서 추가된 **var** 키워드는 코드의 가독성을 높이고 코드량을 줄일 수 있습니다. 이전에는 변수의 타입을 명시적으로 선언해야 했지만 **var** 키워드를 사용하면 컴파일러가 변수의 타입을 추론하도록 할 수 있습니다.

예를 들어, 이전에는 다음과 같이 변수를 선언해야 했습니다.

```
List<String> list = new ArrayList<String>();
```

하지만 **var** 키워드를 사용하면 다음과 같이 코드를 작성할 수 있습니다.

```
var list = new ArrayList<String>();
```

**var** 키워드를 사용하면 코드가 더 간결해지고 가독성이 높아집니다. 또한 변수의 타입이 바뀌더라도 코드를 수정할 필요가 없습니다.

**var** 키워드는 다음과 같은 제약 사항이 있습니다.

- 지역 변수에서만 사용할 수 있습니다.
- 변수 선언과 동시에 초기화해야 합니다.
- 초기화 식의 타입을 기반으로 변수의 타입을 추론합니다.

예를 들어, 다음과 같은 코드는 컴파일되지 않습니다.

```
var x;
x = 10;
```

컴파일러는 **x**의 타입을 추론할 수 없기 때문에 컴파일 오류가 발생합니다.

마지막으로, **var** 키워드를 사용할 때에는 변수의 이름을 잘 지어야 합니다. 변수의 이름을 잘 지으면 코드의 가독성이 향상되고, 변수의 타입이 명시적으로 표현되기 때문입니다.
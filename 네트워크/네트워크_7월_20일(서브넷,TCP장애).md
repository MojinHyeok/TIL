네트워크 

# 퇴근시간을 결정하는 TCP 장애유형 5가지

TCP라는 프로토콜은 생각보다 복잡하고 정교하다.

대원칙은(순서) Layered하다고 가정 4층이 있으려면 1층2층 3층이 다 되어 있다고 가정하고 시작.

아래에서 위로!

TCP라는건 IP가 전제하고 TCP가 된다고 가정.



①.L1,L2수준에서 나오는 에러 Loss가 나타나는 현상 End Point입장에서 받지를 못하는 현상.(값을 보냈는데 받지못하는)

랜선 빠졌거나, 많은 이유가 있다.

②.Duplicate Ack

③Retransmission

위의 두가지의 경우(L3,L4)

네트워크 지연을 의심해야하고, 커널을 의심한번 해봐야한다. Timer 계산.

위의 3가지 경우를 혼잡이라고 본다.



④WindowSize가 Zero인 경우

주로 어플리케이션을 의심해봐야한다.(수신측 버퍼를 의심)

⑤RST

TCP소켓이 리셋되는 현상.

프로그램이 잘 다운로드 받고 있다가 Kill되어 리셋 되어지는 현상.

뭔가 프로그램이 정상적이지 않은 절차로 죽어버렸거나, 소켓이 EndPoint프로세스에서 비정상 적인 상태로 날라가버린 상태.



# 네트워크를 다시 또 내부로 자르는 서브넷팅

![img](https://blog.kakaocdn.net/dn/IbRG5/btrHL3vip7T/n3PulC1ILGTKm5tp9KUlqK/img.png)

서브넷? 왜?

IP주소의 구조는

8비트씩 4개로 32bit를 가집니다.

서브넷을 설명할 때는 비트 연산을 알고 있다고 가정 (and or 이런연산)

C클래스의 경우 24Bit를 NetID로 사용하고 8Bit를 Host ID로 사용합니다.

그런데 여기서 못쓰는 주소가 있는데

값이 전체가 0이거나 1(BroadCast)이면 사용하지 못합니다. Host에서 256에서 -2를해서 254개 주소를 사용할 수 있습니다.

C클래스가 하나가 있다고 가정했을 때

ISP입장에서 생각했을때

회사가 공인 IP주소 100개를 주라고 했을 때 

254개중에 100개만 사용하게되어지고 154개는 버려지게 되어집니다.

그래서 이걸 활용하기 위해서 서브넷팅을 사용하는데 C클래스가 가장 작은 클래스인데 거기서 한번더 쪼개는 개념 (A클래스 B클래스도 사용하긴 한다.)



